import logging

from sqlalchemy.dialects.postgresql import insert
from sqlalchemy.orm import Session
from telegram import Update
from telegram.ext import (CallbackQueryHandler, CommandHandler, ContextTypes, ConversationHandler, MessageHandler,
                          filters)

import helpers
import models
import settings
from patreon import fetch_patrons

CONNECT_PATREON = 1


async def start_connect_patreon(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    logging.info(f"start_connect_patreon handler triggered by {helpers.repr_user_from_update(update)}")
    if update.callback_query:
        await update.callback_query.answer()
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=f"–í–≤–µ–¥–∏ –ø–æ—á—Ç—É, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–≤—è–∑–∞–Ω–∞ –∫ —Ç–≤–æ–µ–º—É –ø—Ä–æ—Ñ–∏–ª—é Patreon."
    )
    return CONNECT_PATREON


# we will store it regardless it's a paying patron or not
# we just store the pairing of tg_id to patreon email
# to know if it's paying patron or not, check redis
async def store_patreon_linking(update: Update, patron_email: str, context: ContextTypes.DEFAULT_TYPE) -> bool:
    with Session(models.engine) as session:
        user = helpers.get_user(update)
        patreon_link = {
            'tg_id': user.id,
            'tg_username': user.username,
            'patreon_email': patron_email
        }
        stmt = insert(models.PatreonLink).values(**patreon_link)
        stmt = stmt.on_conflict_do_update(
            constraint='PatreonLink_pkey',
            set_=patreon_link
        )
        session.execute(stmt)
        try:
            session.commit()
            logging.info(f"Added new patron linking: {user.username} to {patron_email} to db")
        except Exception as e:
            # I don't rely on handlers.handlers.error_handler because in this case ConversationHandler.END will not be
            # returned and commands after this exception will be ignored
            session.rollback()
            logging.warning(f"Didn't add patron linking: {user.username} to {patron_email} to db: {e}")
            await context.bot.send_message(
                chat_id=settings.ADMIN_CHAT_ID,
                text=f"–ù–µ —Å–º–æ–≥ –ø—Ä—è–≤—è–∑–∞—Ç—å Patreon –ø–æ—á—Ç—É {patron_email} –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user.username}: {e}"
            )
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=f"–£–ø—Å! –°–ª—É—á–∏–ª–∞—Å—å –æ—à–∏–±–∫–∞, –Ω–æ –ø—Ä–æ–±–ª–µ–º–∞ –Ω–µ –≤ —Ç–µ–±–µ! –£–∂–µ –æ–ø–æ–≤–µ—Å—Ç–∏–ª @lenka_colenka"
            )
            return False
    return True


async def connect_with_email(update: Update, context: ContextTypes.DEFAULT_TYPE) \
        -> int:
    logging.info(f"connect_with_email handler triggered by {helpers.repr_user_from_update(update)}")
    email_to_find = update.message.text.strip().lower()
    logging.info(f"looking for patron with email {email_to_find}")

    # this method loads patrons from patreon and does lookup in redis
    patron_info = fetch_patrons.get_patron_by_email(email_to_find)
    if patron_info:
        if await store_patreon_linking(update, email_to_find, context):
            logging.info(f"Patron found for email {email_to_find}: {patron_info}")
            msg: str = f"–ù–∞—à–ª–∞ —Ç–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å Patron: {email_to_find}.\n\n"
            donate_amount_cents = int(patron_info['currently_entitled_amount_cents'])
            if donate_amount_cents > 1500:
                msg += f"–¢—ã –¥–æ–Ω–∞—Ç–∏—à—å –º–Ω–µ ${100*patron_info['currently_entitled_amount_cents']} –≤ –º–µ—Å—è—Ü. –°–ø–∞—Å–∏–±–æ! ü•π",
            elif 0 < donate_amount_cents < 1500:
                msg += (f"–¢—ã –¥–æ–Ω–∞—Ç–∏—à—å –º–Ω–µ ${100*patron_info['currently_entitled_amount_cents']} –≤ –º–µ—Å—è—Ü. –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å "
                        f"Pro –ø–æ–¥–ø–∏—Å–∫—É, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ –æ—Ñ–æ—Ä–º–∏ –¥–æ–Ω–∞—Ç –Ω–∞ $15 –≤ –º–µ—Å—è—Ü ü•π")
            else:
                msg += (f"–¢—ã –ø–æ–∫–∞ –Ω–µ –¥–æ–Ω–∞—Ç–∏—à—å –º–Ω–µ –Ω–∞ Patreon. –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å Pro –ø–æ–¥–ø–∏—Å–∫—É, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ –æ—Ñ–æ—Ä–º–∏ –¥–æ–Ω–∞—Ç –Ω–∞ "
                        f"$15 –≤ –º–µ—Å—è—Ü ü•π")
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=msg,
            )
        else:
            return ConversationHandler.END
    else:
        logging.info(f"Could not find patron for email {email_to_find}")
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"–ù–µ –Ω–∞—à–ª–∞ –ø–∞—Ç—Ä–æ–Ω–∞ –ø–æ email {email_to_find}. –ü—Ä–æ–≤–µ—Ä—å, —á—Ç–æ –≤—Å–µ –≤–µ—Ä–Ω–æ –∏–ª–∏ –Ω–∞–ø–∏—à–∏ @lenka_colenka",
        )
    return ConversationHandler.END


async def cancel_connect(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    logging.info(f"cancel_connect handler triggered by {helpers.repr_user_from_update(update)}")
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="–û—Ç–º–µ–Ω–∞ –ø—Ä–∏–≤—è–∑–∫–∏ –ø–∞—Ç—Ä–æ–Ω–∞",
    )
    return ConversationHandler.END


connect_patreon_handler = ConversationHandler(
    entry_points=[
        CommandHandler('connect_patreon', start_connect_patreon),
        CallbackQueryHandler(start_connect_patreon, '^connect_patreon$')
    ],
    states={CONNECT_PATREON: [MessageHandler(filters.TEXT & ~filters.COMMAND, connect_with_email)]},
    fallbacks=[CommandHandler('cancel_connect', cancel_connect)],
)
